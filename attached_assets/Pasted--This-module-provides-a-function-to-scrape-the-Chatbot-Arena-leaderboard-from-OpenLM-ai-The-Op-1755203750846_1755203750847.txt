"""
This module provides a function to scrape the Chatbot¬†Arena+ leaderboard from OpenLM.ai.

The OpenLM.ai website lists an aggregated leaderboard that includes the latest Chatbot¬†Arena
Elo rankings alongside several other benchmarks (coding, vision, AAII, MMLU‚ÄëPro and
ARC‚ÄëAGI).  Unlike LMArena, OpenLM.ai does not expose an official API for this data,
and the HTML table is dynamically sortable via JavaScript.  However, the core
table markup is present in the page source, so it can be parsed with BeautifulSoup.

This script defines a helper function, ``scrape_openlm_chatbot_arena``, that fetches
the leaderboard page, parses the HTML to extract the table rows and columns, and
returns a ``pandas.DataFrame`` with the results.  The columns in the returned
DataFrame mirror the display on the site: ``rank_icon``, ``model``, ``arena_elo``,
``coding``, ``vision``, ``aaii``, ``mmlu_pro``, ``arc_agi``, ``organisation`` and
``license``.  Empty fields on the site become ``None`` in the DataFrame.

Example usage::

    from scrape_openlm_chatbot_arena import scrape_openlm_chatbot_arena

    df = scrape_openlm_chatbot_arena()
    print(df.head())

If the target page is unreachable due to access restrictions, you can
first download its HTML using your browser and then pass that HTML content
directly to the ``parse_leaderboard_html`` helper.  See the ``__main__`` block
for a demonstration.

Dependencies:
    - requests
    - beautifulsoup4
    - pandas

Note: OpenLM.ai may employ anti‚Äëbot measures.  Including a User‚ÄëAgent header,
and optionally adding a small delay between requests, can help avoid a 403.
"""

import re
from typing import List, Optional

import pandas as pd
import requests
from bs4 import BeautifulSoup


def parse_leaderboard_html(html: str) -> pd.DataFrame:
    """Parse Chatbot¬†Arena+ leaderboard HTML into a pandas DataFrame.

    Args:
        html: Raw HTML of the Chatbot¬†Arena+ page.

    Returns:
        A ``pandas.DataFrame`` with one row per model and columns:
        ``rank_icon``, ``model``, ``arena_elo``, ``coding``, ``vision``,
        ``aaii``, ``mmlu_pro``, ``arc_agi``, ``organisation``, ``license``.

    Raises:
        ValueError: If no table with class ``sortable`` is found in the HTML.
    """
    soup = BeautifulSoup(html, "html.parser")
    table = soup.find("table", {"class": "sortable"})
    if table is None:
        raise ValueError("Could not find leaderboard table in the provided HTML.")

    headers = [
        "rank_icon",
        "model",
        "arena_elo",
        "coding",
        "vision",
        "aaii",
        "mmlu_pro",
        "arc_agi",
        "organisation",
        "license",
    ]
    data: List[List[Optional[str]]] = []

    # Iterate over each table row in tbody
    tbody = table.find("tbody")
    for row in tbody.find_all("tr"):
        cols = row.find_all("td")
        if not cols:
            continue
        row_data: List[Optional[str]] = []
        # Column 0: rank icon (üèÜ, ü•á, ü•à, etc.)
        rank_icon = cols[0].get_text(strip=True) if cols[0] else None
        row_data.append(rank_icon)
        # Column 1: model name
        model = cols[1].get_text(strip=True) if cols[1] else None
        row_data.append(model)
        # Columns 2-8: numeric metrics (code inside <code> tags)
        for i in range(2, 8):
            cell = cols[i] if i < len(cols) else None
            if cell:
                # If the cell contains code tags, extract the numeric text
                code_tags = cell.find_all("code")
                if code_tags:
                    # Some cells highlight the highest value within <span class="mark"><strong><code>...</code></strong></span>
                    # We take the first <code> tag value
                    value = code_tags[0].get_text(strip=True)
                else:
                    value = cell.get_text(strip=True)
                row_data.append(value if value else None)
            else:
                row_data.append(None)
        # Column 8: organisation (contains text after an optional <img> or <svg> icon)
        organisation_cell = cols[8] if len(cols) > 8 else None
        organisation = None
        if organisation_cell:
            # Remove any <img> or <svg> tags then get remaining text
            for tag in organisation_cell.find_all(["img", "svg"]):
                tag.decompose()
            organisation = organisation_cell.get_text(strip=True) or None
        row_data.append(organisation)
        # Column 9: license
        license_cell = cols[9] if len(cols) > 9 else None
        license_value = license_cell.get_text(strip=True) if license_cell else None
        row_data.append(license_value)
        data.append(row_data)

    df = pd.DataFrame(data, columns=headers)
    return df


def scrape_openlm_chatbot_arena(url: str = "https://openlm.ai/chatbot-arena/",
                                 timeout: float = 15.0,
                                 user_agent: Optional[str] = None) -> pd.DataFrame:
    """Fetch and parse the Chatbot¬†Arena+ leaderboard.

    Args:
        url: The URL of the leaderboard page (default: Chatbot¬†Arena+).
        timeout: Timeout in seconds for the HTTP request.
        user_agent: Optional custom User‚ÄëAgent string to include in the request.

    Returns:
        A pandas DataFrame with the leaderboard data.

    Raises:
        requests.HTTPError: If the HTTP request fails.
        ValueError: If no table is found in the HTML.
    """
    headers = {}
    if user_agent:
        headers["User-Agent"] = user_agent
    else:
        headers["User-Agent"] = (
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
            "AppleWebKit/537.36 (KHTML, like Gecko) "
            "Chrome/115.0 Safari/537.36"
        )
    response = requests.get(url, headers=headers, timeout=timeout)
    # Raise an exception for HTTP errors (e.g., 403)
    response.raise_for_status()
    return parse_leaderboard_html(response.text)


if __name__ == "__main__":
    # When run as a script, attempt to scrape the leaderboard.  If the network
    # request fails (e.g., due to a 403), fall back to parsing HTML provided
    # on STDIN.  To test with saved HTML, run:
    #   python scrape_openlm_chatbot_arena.py < saved_page.html
    import sys
    try:
        df = scrape_openlm_chatbot_arena()
        print("Successfully scraped {} rows.".format(len(df)))
        print(df.head())
    except Exception as exc:
        # If scraping fails, attempt to read HTML from stdin
        html_content = sys.stdin.read()
        if not html_content.strip():
            raise SystemExit(f"Error scraping leaderboard: {exc}")
        df = parse_leaderboard_html(html_content)
        print("Parsed {} rows from provided HTML.".format(len(df)))
        print(df.head())